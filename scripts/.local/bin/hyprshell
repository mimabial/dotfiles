#!/usr/bin/env bash
# This script will soon be used to resolve $PATHS and LIB_DIR
python_initialized() {
  python "${LIB_DIR}/hypr/pyutils/pip_env.py" rebuild
}

python_activate() {

  local python_env="${XDG_STATE_HOME:-$HOME/.local/state}/hypr/pip_env/bin/activate"
  if [[ -r "${python_env}" ]]; then
    # shellcheck disable=SC1090
    source "${python_env}"
  else
    printf "Warning: Python virtual environment not found at %s\n" "${python_env}"
    printf "You may need to run 'hyprshell pyinit' to set it up.\n"
    python_initialized
  fi

}

initialized() {
  cat <<EOF
HYPR_SHELL_INIT=1
BIN_DIR="${BIN_DIR}"
LIB_DIR="${LIB_DIR}"
SHARE_DIR="${SHARE_DIR}"
PATH=${PATH}
HYPR_SCRIPTS_PATH=${HYPR_SCRIPTS_PATH}
export BIN_DIR LIB_DIR SHARE_DIR PATH HYPR_SCRIPTS_PATH HYPR_SHELL_INIT
EOF
  #? Use sed to remove any shebang hints to avoid conflicts with "eval"
  command cat "${LIB_DIR}/hypr/globalcontrol.sh" | sed '1{/^#!/d;}'
}

USAGE() {

  cat <<USAGE
Usage: $(basename "$0") [command]
Commands:
  --help, help, -h              : Display this help message
  -r, reload                    : Reload Hyprland Environment
  release-notes                 : Show release notes
  completions [bash|zsh|fish]   : Generate shell completions
  validate [args]               : Validate Hyprland configuration
  pyinit                        : Initialize python virtual environment
  version                       : Show version information
  init                          : Source initialization script

Available commands:

$(list_script)

USAGE

}

hyprreload() {

  print_log -sec "Hyprland" "Reloading Hyprland Environment"
  python_initialized
  "$LIB_DIR/hypr/swwwallcache.sh" -t ""
  "$LIB_DIR/hypr/theme.switch.sh"
}

list_script() {
  # Use HYPR_SCRIPTS_PATH to find scripts from all configured directories
  local HYPR_SCRIPTS_PATH="${HYPR_SCRIPTS_PATH:-${XDG_CONFIG_HOME:-$HOME/.config}/hypr/scripts:${LIB_DIR}/hypr}"

  # Convert to array, deduplicate, and filter out empty entries
  IFS=':' read -ra RAW_DIRS <<<"$HYPR_SCRIPTS_PATH"
  declare -A seen_dirs
  local SCRIPT_DIRS=()
  for dir in "${RAW_DIRS[@]}"; do
    # Skip empty entries (handles multiple colons like :::)
    [[ -z "$dir" ]] && continue
    # Deduplicate directories
    [[ -n "${seen_dirs[$dir]}" ]] && continue
    seen_dirs["$dir"]=1
    # Only add existing directories
    [[ -d "$dir" ]] && SCRIPT_DIRS+=("$dir")
  done

  # Find scripts in all configured directories
  for dir in "${SCRIPT_DIRS[@]}"; do
    find -L "$dir" -maxdepth 1 -type f \( -name "*.sh" -o -name "*.py" \) -exec basename {} \; 2>/dev/null
  done | sort -u
}

list_script_path() {
  find -L "$LIB_DIR/hypr" -type f \( -name "*.sh" -o -name "*.py" \) -exec echo {} \;
}

get_completion_data() {
  # Get all available commands and scripts
  local built_in_commands=("--help" "help" "-h" "-r" "reload" "--version" "version" "-v" "--release-notes" "release-notes" "--list-script" "--list-script-path" "--completions")
  local hyprscripts=()

  # Get scripts (remove extensions)
  while IFS= read -r script; do
    if [[ -n "$script" ]]; then
      script_name="${script%.*}"
      hyprscripts+=("$script_name")
    fi
  done < <(list_script 2>/dev/null | sort -u)

  # Export arrays for use by completion generators
  export HYPR_BUILT_IN_COMMANDS="${built_in_commands[*]}"
  export HYPR_SCRIPTS="${hyprscripts[*]}"
}

gen_bash_completion() {
  get_completion_data

  cat <<'BASH_COMPLETION'
# Bash completion for hyprshell
_hyprshell_completion() {
    local cur prev words cword
    _init_completion 2>/dev/null || {
        COMPREPLY=()
        cur="${COMP_WORDS[COMP_CWORD]}"
        prev="${COMP_WORDS[COMP_CWORD-1]}"
    }

    local built_in_commands hyprscripts
    built_in_commands="--help help -h -r reload --version version -v --release-notes release-notes --list-script --list-script-path --completions"

    # Get dynamic completions from hyprshell
    if command -v hyprshell >/dev/null 2>&1; then
        hyprscripts=$(hyprshell --list-script 2>/dev/null | sed 's/\.[^.]*$//' | tr '\n' ' ')
    fi

    # Only provide completions for the first argument
    if [[ $COMP_CWORD -eq 1 ]]; then
        # First argument: complete with all available commands
        local all_commands="$built_in_commands $hyprscripts"
        COMPREPLY=($(compgen -W "$all_commands" -- "$cur"))
    elif [[ $COMP_CWORD -eq 2 ]]; then
        # Second argument: only for specific commands that take arguments
        case $prev in
            --completions)
                COMPREPLY=($(compgen -W "bash zsh fish" -- "$cur"))
                return 0
                ;;
            *)
                # No completion for other commands
                COMPREPLY=()
                return 0
                ;;
        esac
    else
        # No completion for 3rd argument and beyond
        COMPREPLY=()
        return 0
    fi
}

complete -F _hyprshell_completion hyprshell
BASH_COMPLETION
}

gen_zsh_completion() {
  get_completion_data

  cat <<'ZSH_COMPLETION'
#compdef hyprshell

_hyprshell() {
    local cur prev words
    cur="${words[CURRENT]}"
    prev="${words[CURRENT-1]}"

    local built_in_commands hyprscripts
    built_in_commands=("--help" "help" "-h" "-r" "reload" "--version" "version" "-v" "--release-notes" "release-notes" "--list-script" "--list-script-path" "--completions")

    # Get dynamic completions
    if (( $+commands[hyprshell] )); then
        local scripts_raw
        scripts_raw=(${(f)"$(hyprshell --list-script 2>/dev/null)"})
        hyprscripts=(${scripts_raw[@]%.*})  # Remove extensions
    fi

    # Only complete for first two arguments max
    if [[ $CURRENT -eq 2 ]]; then
        # First argument: all commands
        local all_commands=($built_in_commands $hyprscripts)
        compadd -a all_commands
    elif [[ $CURRENT -eq 3 ]]; then
        # Second argument: only for specific commands
        case $words[2] in
            --completions)
                compadd "bash" "zsh" "fish"
                return 0
                ;;
            *)
                # No completion for other commands
                return 0
                ;;
        esac
    else
        # No completion for 3rd argument and beyond
        return 0
    fi
}

compdef _hyprshell hyprshell
ZSH_COMPLETION
}

gen_fish_completion() {
  get_completion_data

  cat <<'FISH_COMPLETION'
# Fish completion for hyprshell

function __hyprshell_get_commands
    echo "--help
help
-h
-r
reload
--version
version
-v
--release-notes
release-notes
--list-script
--list-script-path
--completions"

    # Get scripts
    if command -v hyprshell >/dev/null 2>&1
        hyprshell --list-script 2>/dev/null | sed 's/\.[^.]*$//'
    end
end

# Main completions
complete -c hyprshell -f

# First argument completions
complete -c hyprshell -n "not __fish_seen_subcommand_from (__hyprshell_get_commands)" -a "(__hyprshell_get_commands)" -d "hyprshell commands"

# Completions subcommand
complete -c hyprshell -n "__fish_seen_subcommand_from --completions" -a "bash zsh fish" -d "Shell completion types"

# Option descriptions
complete -c hyprshell -s h -l help -d "Display help message"
complete -c hyprshell -s r -d "Reload config"
complete -c hyprshell -s v -l version -d "Show version information"
complete -c hyprshell -l release-notes -d "Show release notes"
complete -c hyprshell -l list-script -d "List available scripts"
complete -c hyprshell -l list-script-path -d "List scripts with full paths"
complete -c hyprshell -l completions -d "Generate shell completions"
FISH_COMPLETION
}

generate_completions() {
  local shell_type="$1"

  case "$shell_type" in
    bash)
      gen_bash_completion
      ;;
    zsh)
      gen_zsh_completion
      ;;
    fish)
      gen_fish_completion
      ;;
    *)
      echo "Usage: hyprshell --completions [bash|zsh|fish]"
      echo "Generate shell completions for the specified shell"
      return 1
      ;;
  esac
}

hyprlogout() {
  if uwsm check is-active; then
    uwsm stop
  elif [[ -n "${HYPRLAND_INSTANCE_SIGNATURE}" ]]; then
    hyprctl dispatch exit 0
  fi
}

run_command() {
  # Convert to array, deduplicate, and filter out empty entries
  IFS=':' read -ra RAW_DIRS <<<"$HYPR_SCRIPTS_PATH"
  declare -A seen_dirs
  SCRIPT_DIRS=()
  for dir in "${RAW_DIRS[@]}"; do
    # Skip empty entries (handles multiple colons like :::)
    [[ -z "$dir" ]] && continue
    # Deduplicate directories
    [[ -n "${seen_dirs[$dir]}" ]] && continue
    seen_dirs["$dir"]=1
    # Only add existing directories
    [[ -d "$dir" ]] && SCRIPT_DIRS+=("$dir")
  done

  # Try to find and execute the command in priority order
  for dir in "${SCRIPT_DIRS[@]}"; do
    # Try .sh extension first
    if [[ -f "$dir/${1}.sh" ]]; then
      exec bash "$dir/${1}.sh" "${@:2}"
    # Try .py extension
    elif [[ -f "$dir/${1}.py" ]]; then
      python_activate
      exec python "$dir/${1}.py" "${@:2}"
    # Try exact name (executable)
    elif [[ -f "$dir/${1}" && -x "$dir/${1}" ]]; then
      exec "$dir/${1}" "${@:2}"
    fi

    # Search subdirectories
    for subdir in "$dir"/*/; do
      [[ ! -d "$subdir" ]] && continue
      if [[ -f "${subdir}${1}.sh" ]]; then
        exec bash "${subdir}${1}.sh" "${@:2}"
      elif [[ -f "${subdir}${1}.py" ]]; then
        python_activate
        exec python "${subdir}${1}.py" "${@:2}"
      elif [[ -f "${subdir}${1}" && -x "${subdir}${1}" ]]; then
        exec "${subdir}${1}" "${@:2}"
      fi
    done
  done

  # Finally try as a direct file path
  if [[ -f "$1" && -x "$1" ]]; then
    exec "$1" "${@:2}"
  else
    echo "Command not found: $1"
    echo "Available commands:"
    list_script
    # Show user scripts from all configured directories (including subdirs)
    for dir in "${SCRIPT_DIRS[@]}"; do
      echo "Scripts in $dir:"
      find -L "$dir" -maxdepth 2 -type f \( -name "*.sh" -o -name "*.py" -o -executable \) -exec basename {} \; 2>/dev/null | sort -u
    done
  fi
}

run_pip() {
  python_activate
  shift
  pip "$@"
}

run_pypr() {

  python_activate
  shift

  if command -v pypr >/dev/null 2>&1; then

    socket_path="${XDG_RUNTIME_DIR}/hypr/${HYPRLAND_INSTANCE_SIGNATURE}/.pyprland.sock"
    if [[ -f "${XDG_CONFIG_HOME:-$HOME/.config}/hypr/pyprland.toml " ]]; then
      send_notifs "Missing pyprland.toml" "Please create a pyprland.toml file in ${XDG_CONFIG_HOME:-$HOME/.config}/hypr/ to configure PyPR."
      exit 1
    fi

    if [[ -S "$socket_path" ]] && pgrep -u "$USER" pypr >/dev/null 2>&1; then
      message="${*:-"help"}"
      # Send the message to the socket and print the response
      if ! printf "%s" "${message[@]}" | nc -N -U "$socket_path" 2>/dev/null; then #! openbsd netcat only
        if ! printf "%s" "${message[@]}" | socat - UNIX-CONNECT:"$socket_path" 2>/dev/null; then
          if ! printf "%s" "${message[@]}" | ncat -U "$socket_path" 2>/dev/null; then
            if ! pypr "${message[@]}"; then
              print_log -sec "pypr" "Error communicating with socket: $socket_path"
              exit 1
            fi
          fi
        fi
      fi

    else
      print_log -sec "pypr" "PyPR is not running properly, starting fresh"
      [[ -S "$socket_path" ]] && print_log -y "Removing stale socket: $socket_path"
      pgrep -u "$USER" pypr >/dev/null && print_log -y "Killing existing pypr process"
      rm -f "$socket_path"

      exec app2unit.sh -t service pypr
    fi

  else
    pip install --no-input pyprland==2.4.7
  fi

}

lock_session() {
  #? hyprshell lock-session wraps around the lockscreen.sh script
  #? lockscreen.sh activates the set lockscreen blindly
  #? however, lock-session will check if the lockscreen is set FD's ScreenSaver
  #? if it is, it will use loginctl lock-session
  #? otherwise, it will use lockscreen.sh
  if busctl --user list | grep -q "org.freedesktop.ScreenSaver"; then
    echo "Using org.freedesktop.ScreenSaver for locking"
    loginctl lock-session
  else
    lockscreen.sh
  fi

}

#*--------------------------------------------------------------------------------

if [[ -z "${BASH_SOURCE[0]}" ]]; then
  EXECUTABLE="${0}"
else
  EXECUTABLE="${BASH_SOURCE[0]}"
fi

BIN_DIR=$(dirname "$(which "${EXECUTABLE:-hyprshell}")")
LIB_DIR=$(realpath "${BIN_DIR}/../lib")
SHARE_DIR=$(realpath "${BIN_DIR}/../share")
# Add lib/hypr and all its subdirectories to PATH
HYPR_LIB_PATH="$LIB_DIR/hypr"
for subdir in "$HYPR_LIB_PATH"/*/; do
  [[ -d "$subdir" ]] && HYPR_LIB_PATH="$HYPR_LIB_PATH:$subdir"
done
PATH="${XDG_CONFIG_HOME:-$HOME/.config}/hypr/scripts:$BIN_DIR:$HYPR_LIB_PATH:$PATH"
# Define scripts search paths (colon-separated, user configurable)
HYPR_SCRIPTS_PATH="${HYPR_SCRIPTS_PATH:-${XDG_CONFIG_HOME:-$HOME/.config}/hypr/scripts:${LIB_DIR}/hypr}:${XDG_DATA_HOME}/waybar/scripts:${XDG_CONFIG_HOME}/waybar/scripts"

export BIN_DIR LIB_DIR SHARE_DIR PATH HYPR_SCRIPTS_PATH

#*--------------------------------------------------------------------------------

# Priority commands
case "$1" in
  app)
    export PATH="${HYPR_SCRIPTS_PATH}:${PATH}"
    [[ "${HYPRPY}" -eq 1 ]] && python_activate
    shift
    exec app2unit.sh "$@"
    ;;
  init | --init)
    initialized
    exit 0
    ;;
  lock-session)
    lock_session
    exit 0
    ;;
  *)
    export HYPR_SHELL_INIT=1
    ;;
esac

# shellcheck disable=SC1091
if ! source "${LIB_DIR}/hypr/globalcontrol.sh"; then
  echo "Error: Could not load config, broken installation?"
  exit 1
fi

#*--------------------------------------------------------------------------------

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then

  case $1 in
    logout)
      hyprlogout
      ;;

    pypr)
      run_pypr "${@}"
      exit 0
      ;;

    pip)
      run_pip "${@}"
      exit 0
      ;;
    -r | reload)
      hyprreload
      ;;
    --release-notes | release-notes)
      get_release_notes
      ;;
    --version | version | -v)
      get_version
      ;;
    --help | help | -h)
      USAGE
      ;;
    --list-script)
      list_script
      ;;
    --list-script-path)
      list_script_path
      ;;
    --completions)
      shift
      generate_completions "$1"
      ;;
    validate)
      shift
      if command -v parse.config.py >/dev/null 2>&1; then
        parse.config.py --input "$XDG_CONFIG_HOME/hypr/config.toml" --env "$XDG_STATE_HOME/hypr/config" --hypr "$XDG_STATE_HOME/hypr/hyprland.conf" "${@}"
      else
        echo "parse.config.py not found. Please make sure it is in \$PATH."
      fi
      exit 0
      ;;
    pyinit)
      python_initialized
      ;;
    "")
      for func in $(compgen -A function); do
        export -f "${func?}"
      done
      ;;
    *)
      run_command "$@"
      ;;
  esac

fi
